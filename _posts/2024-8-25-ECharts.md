---
title: ECharts
date: 2024-8-16 20:30:21
tags: ECharts
categories: 技术框架
toc: true
---

> 本文为 ECharts 汇总。

<!-- more -->

## 基本配置
### yAxis
#### yAxis 坐标轴固定分割段数
配置 interval 配合 min 和 max 来进行控制，取出数据中的最大最小值，例如要固定分割为 5 段区间，那 interval 则为 max/5，要注意处理小数的情况，可以向上取整，参考[ECharts yAxis.interval](https://echarts.apache.org/zh/option.html#yAxis.interval)详细配置。
```js
let max = Math.max(...list)
let interval = Math.ceil(max / 5)
// 保持最大值为间隔的5倍
// 举个例子，当前范围是 0-9，要进行5等分，间隔向上取整后为2，若不对 max 处理，则y轴展示：0、2、4、6、8、9，看着非常不协调，所以算出 interval 之后，将 max 乘以 5，以达到间隔均等的目的，就变成：0、2、4、6、8、10。
max = 5 * interval

yAxis: {
    min: 0,
    max,
    interval,
},
```

## 其他配置
### ZRender
ZRender，通过 getZr 进行调用，getZr 为 ECharts 私有函数，后续有可能会修改或移除，最好不要更新版本，若要更新，需要自测一下使用了 getZr 功能的模块是否正常。

使用 ZRender 可以扩展 ECharts 的功能，比如监听整个画布的事件，再比如柱状图点击当前柱图整个区域都能触发柱图的点击，都可以通过 ZRender 来实现。

因为 ZRender 为私有属性，所以也不列在官方文档中，更多使用还是自行探索，当然也不建议过多使用私有属性，万一真到了需要最新版本的某一功能而最新版本移除了 ZRender就会很被动了。

## GL系列
### map3D
#### DEMO
```javascript
let json // 这里添加地图数据
echarts.registerMap('3dMap', json)

myChart.setOption({
  tooltip: {
    show: true,
    backgroundColor: '#0C2257',
    borderColor: '#0C2257'
  },
  series: [
    {
      type: 'map3D',
      name: '地图',
      map: '3dMap',
      regionHeight: 3, // 地图高度
      viewControl: {
        distance: 100, // 地图视角 控制初始大小
        maxDistance: 130, // 最大距离
        alpha: 50, // 视角绕 x 轴，即上下旋转的角度
        beta: 0, // 视角绕 y 轴，即左右旋转的角度
        animation: false, // 控制 3D 地图视图在调整时是否使用动画过渡效果
        center: [5, 0, 0] // 中心
      },
      bottom: '10',
      data: [],
      itemStyle: {
        borderWidth: 0.5, // 分界线wdith
        borderColor: '#ccc', // 分界线颜色
        opacity: 1,
        color: '#5D99DF'
      },
      emphasis: {
        itemStyle: {
          color: '#4791c4 '
        }
      },
      light: {
        // 场景主光源的设置，在 globe 组件中就是太阳光
        main: {
          color: '#fff',
          intensity: 0.7, // 主光源的强度
          shadow: true,
          shadowQuality: 'low', // 阴影的质量。可选'low', 'medium', 'high', 'ultra'
          alpha: 45,
          beta: -90
        },
        // 全局的环境光设置
        ambient: {
          color: '#7DD0FF',
          intensity: 0.6
        }
      }
    }
  ]
});
```

#### 指定区域凸起
参考[中国地图实现如何实现鼠标滑过省，省单独的区域regionHeight发生变化](https://github.com/apache/echarts/issues/11185)，这里文档很坑爹，写的是 regionHeight，但是试了多次无效，最后查了半天，在官方issue中找到了解决方案，实际上是要设置 height 属性。

#### 指定区域边框
官方文档写了支持，但是实际上并不支持单独设置边框，包括 borderWidth 和 borderColor。

#### 添加逐帧动画
原理是通过修改label的背景为图片或者为canvas元素，通过实时更新背景达到逐帧动画的效果。
通过canvas编译动画的好处是可以随意对图片进行剪裁等处理，不需要再用图片处理工具单独处理图片了。
- [rich使用文档](https://echarts.apache.org/zh/option.html#series-bar.label.rich.%3Cstyle_name%3E)
- [地图数据-阿里云DataV数据可视化](https://datav.aliyun.com/portal/school/atlas/area_selector)

```javascript
// label 配置 canvas 部分
label: {
    show: true,
    formatter: function (params) {
        return `{img|}{name|${params.name}}`
    },
    rich: {
        img: {
            backgroundColor: {
                image: canvasElement, // 图片路径
                // 这里可以是图片的 URL
                // 或者图片的 dataURI
                // 或者 HTMLImageElement 对象
                // 或者 HTMLCanvasElement 对象
            },
            width: 30,
            height: 80,
        },
        name: {
            color: '#fffcf8',
            fontSize: 14,
            verticalAlign: 'bottom',
            padding: [0, 0, 0, 1],
        },
    },
},

// 预加载图片
// 将逐帧动画全部预加载后再渲染到 ECharts，不会重置 tooltip
const preLoadedImages = {}
const preLoadedImagesTasks = []
for (const key in imageList) {
    images.push(key)
    preLoadedImagesTasks.push(loadImage(key))
}

async function init() {
    await Promise.all(preLoadedImagesTasks)
    await createCanvas()
    // renderChart
}

function loadImage(src) {
    return new Promise((resolve, reject) => {
        if (preLoadedImages[src]) {
            resolve(preLoadedImages[src])
        } else {
            const img = new Image()
            img.src = src
            img.onerror = reject
            img.onload = () => {
                preLoadedImages[src] = img
                resolve(img)
            }
        }
    })
}

async function createCanvas() {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    canvasElement = canvas

    let currentIndex = 0

    const motionAnimation = async () => {
        try {
            const img = await loadImage(images[currentIndex])
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            ctx.drawImage(img, 90, 0, 72, 210, 0, 0, canvas.width, canvas.height)

            // 更新图片索引
            currentIndex = (currentIndex + 1) % images.length
            // 渲染到地图上的 canvas 不会主动更新，需要主动去触发更新
            myChart?.resize()
        } catch (error) {
            console.error('image loaded failed: ', error)
        }
    }

    if (!canvasTimer) {
        // 这里可以优化为 requestAnimationFrame
        canvasTimer = setInterval(motionAnimation, 5)
        await motionAnimation()
    }
}
```

#### 优化逐帧动画
因为在 ECharts 添加逐帧动画需要实时去触发图表渲染，当然最好还是用 Three.js 搭配 D3.js 去写 3D 类的效果，自由度比较高，也不用这么多歪门邪道，但是凡事要结合实际情况考虑。在动画流畅度上，即使使用了 requestAnimationFrame 或是设置了 setInterval 最低延时，因为渲染地图需要时间，所以实际还是会大于这个延时，这就会导致动画会有慢放的感觉，解决办法就是抽帧，去减少动画的帧数，达到“加速”的效果，属于一种为图表渲染做的一种妥协，但是确实可以达到目的。

#### 解决动画更新地图导致hover和tooltip重置
因 map3D 加入了动态效果，动态效果需要实时更新，会实时触发 ECharts 的渲染因此会产生一些额外的问题，如下所列：
 1. 地图区域的 hover 效果会因为动态更新而被重置
 2. 地图区域的 tooltip 会因动态更新而被重置

对上述两种情况，进行了如下处理：
 1. 取消地图的 hover 效果，通过 mouseover 事件设置当前地区的 itemStyle，鼠标移出地图再清空所有地区的 itemStyle，当然这里有些复杂，稍后会详细解释。
 2. 将逐帧动画全部预加载后再渲染到 ECharts，不会重置 tooltip，不过有时候还是会有tooltip自动消失的问题，比如地图下钻之后，无法确定具体原因，所以对此可以采用和1一样的方法，设置alwaysShowContent为true，让tooltip始终显示，鼠标移出地图或画布再改为false，并主动dispatch hideTip一次，让tooltip隐藏。

正常情况下，通过监听 mouseout 事件就可以拿到鼠标移出图表的时机，但是调研了一番后发现 map3D 中无法通过 mouseout 事件拿到鼠标移出地图的时机，它只会在地图区域之间的移动触发。所以只能另寻他法：
 1. 尝试了 ZRender 的内置 mouseout 事件，该事件和 echartsInstance 的 globalout 事件一样的效果，只会在移出整个图表触发。
 2. 想通过 ZRender mousemove 拿到坐标，通过坐标转换看能否处理，结果坐标转换在 map3D 中无效。

于是继续调研，看了看官方 issue，也没有类似的提问，相关的博文也没有很多，到这里已经有点头大了，
继续头脑风暴，灵光一现，既然地图和整个画布都有自己的 mousemove 事件，不如通过这两个事件联系起来，说不定可以拿到鼠标移出地图的时机，话不多说直接开干。
总体思路大概是这样，给这两个事件分别添加两个累加计数器，若是在地图上 mousemove(这里会触发 mouseover，先将两个计数器重置)，会同时触发两个计数器，若是计数器相等，则表示鼠标在地图上，反之则表示鼠标移出地图。
说到这里差不多就有解了，这里就不多说了，直接看代码吧，实现上会有些复杂，比如 ZRender 的 mousemove 在地图上时会先触发两次，之后才会触发地图的 mousemove所以就不能用计数器相等的逻辑判断了，要做适当的处理。

```javascript
// map3D 富文本标签部分
label: {
    show: true,
    formatter: function (params) {
        return `{img|}{name|${params.name}}`
    },
    rich: {
        img: {
            backgroundColor: {
                image: canvasElement, // 图片路径
            },
            width: 30,
            height: 80,
        },
        name: {
            color: '#fffcf8',
            fontSize: 14,
            verticalAlign: 'bottom',
            padding: [0, 0, 0, 1],
        },
    },
},

// 核心原理
function bindEvent() {
    let mouseMoveCount = 0 // echartsInstance 计数器
    let ZrMouseMoveCount = 0 // ZRender 计数器

    // 清空自定义样式
    const resetMapItemStyle = (_alwaysShowContent) => {
        let hasItemStyle = false
        let data = myChart.getOption().series[0].data
        let alwaysShowContent = chartOption.tooltip[0].alwaysShowContent

        data.forEach((item) => {
            if (item.itemStyle) {
                hasItemStyle = true
                delete item.itemStyle
            }
        })

        // 做一层判断限定，防止频繁触发地图更新
        if (hasItemStyle) {
            console.log('hasItemStyle')
            myChart.setOption({
                series: [
                    {
                        data,
                    },
                ],
            })
        }

        // 做一层判断限定，防止频繁触发地图更新
        if (_alwaysShowContent != undefined && alwaysShowContent != _alwaysShowContent) {
            console.log('alwaysShowContent != _alwaysShowContent')
            myChart.setOption({
                tooltip: {
                    alwaysShowContent: _alwaysShowContent,
                },
            })
        }

        if (!_alwaysShowContent) {
            myChart.dispatchAction({
                type: 'hideTip',
            })
        }
    }

    // 鼠标移入地图时要重置两个计数器，确保逻辑正确
    myChart.on('mouseover', (params) => {
        console.log('mouseover ', params)
        mouseMoveCount = 0
        ZrMouseMoveCount = 0

        resetMapItemStyle(true)

        let data = myChart.getOption().series[0].data
        data[params.dataIndex].itemStyle = {
            color: '#4791c4',
        }
        myChart.setOption({
            series: [
                {
                    data,
                },
            ],
        })
    })

    // 鼠标移出画布需要处理一次，防止鼠标过快移出画布不能触发mousemove事件而导致无法重置自定义样式
    myChart.on('globalout', (params) => {
        console.log('globalout ', mouseMoveCount)
        mouseMoveCount = 0
        ZrMouseMoveCount = 0
        resetMapItemStyle(false)
    })

    // 只在地图上移动鼠标触发
    myChart.on('mousemove', (params) => {
        mouseMoveCount++
    })

    // 需要注意，getZr 为 ECharts 私有函数，后续有可能会修改或移除，最好不要更新版本，
    // 若要更新，需要自测一下使用了 getZr 功能的模块
    myChart.getZr().on('mousemove', (params) => {
        console.log('===========================')
        console.log('Zr mousemove ', ZrMouseMoveCount)
        console.log('mousemove ', mouseMoveCount)
        ZrMouseMoveCount++
        let count = mouseMoveCount * 2 + 2
        // 鼠标不在地图范围，清空自定义样式
        // 只要保证 ZrMouseMoveCount 大于 count 就可以确定鼠标移出地图了，此时只有 ZRender 的计数器在累加，是一定大于 count 的
        // 所以即使在地图内 mousemove 触发两次也没有关系，不会影响判断
        if (ZrMouseMoveCount > count) {
            resetMapItemStyle(false)
        }
        console.log(`ZrMouseMoveCount:${ZrMouseMoveCount} | count:${count}`)
        console.log(ZrMouseMoveCount > count ? '鼠标不在地图范围内' : '鼠标在地图范围内')
    })
}
```

#### 优化拖拽地图卡顿
大部分情况是由于事件中存在频繁触发更新图表的逻辑，比如上面提到的自定义 hover 效果，就会在 mouseover 中频繁触发图表更新，因此在拖拽过程中尽量不触发任何事件，可以避免因频繁更新图表导致的卡顿。

但是map3d拖拽事件并没有，要自己实现，通过监听地图的 mousedown 和 mouseup 事件来实现，简易方式就是鼠标按下时候认为是在拖拽，鼠标松开结束拖拽，再优化一下则是再按下鼠标时，mousemove 了一段距离后，判定为正在拖拽，鼠标松开结束拖拽。

需要注意的是，要在整个画布上监听鼠标事件，也就是 ZRender 的监听事件。

```javascript
// 简易版本
let isDraging = true

myChart.getZr().on('mousedown', (params) => {
    console.log('mousedown ', params)
    isDraging = true
})

myChart.getZr().on('mouseup', (params) => {
    console.log('mouseup ', params)
    isDraging = false
})
```

```javascript
// 优化版本
let isMouseDown = false
let isDraging = true

myChart.getZr().on('mousemove', (params) => {
    if (isMouseDown) {
        isDraging = true
    }
}

myChart.getZr().on('mousedown', (params) => {
    console.log('mousedown ', params)
    isMouseDown = true
})

myChart.getZr().on('mouseup', (params) => {
    console.log('mouseup ', params)
    isMouseDown = false
    isDraging = false
})
```
